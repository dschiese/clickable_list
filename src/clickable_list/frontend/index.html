<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>clickable-list</title>
  <script src="./streamlit-component-lib.js"></script>
  <script src="./main.js"></script>
  <link rel="stylesheet" href="./style.css" />
</head>
<body>
<div id="root" style="overflow-x: auto;"></div>
<script>
  (function() {
    function renderComponent(data) {
      if (!data || !data.options) return;

      let height = data.options.length * 35;
      const output = document.getElementById("root");
      output.innerHTML = "";  // Clear previous content
      
      // Use a stack to keep track of parent elements at each level
      const parentStack = [output]; // Start with root as the parent
      let currentLevel = 0;
      
      for (let i = 0; i < data.options.length; i++) {
        const item = data.options[i];
        const level = item.level;
        
        // Create the appropriate element
        let node;
        if (i < data.options.length - 1 && data.options[i+1].level > item.level) {
          // This will be a parent of the next item
          node = document.createElement("ul");
        } else {
          node = document.createElement("li");
        }
        
        // Set properties
        node.id = item.id;
        node.innerHTML = item.name;
        if(item.level > 0)
          node.style.marginLeft = `${data.indent}px`;

        if (data.style) 
          node.style.cssText += `${data.style}`;
        
        node.addEventListener("click", (e) => {
          e.stopPropagation();
          Streamlit.setComponentValue(item);
        });
        
        // Handle level change to find the correct parent
        if (level > currentLevel) {
          // Going deeper in the hierarchy - previous node becomes parent
          const newParent = parentStack[parentStack.length - 1].lastChild;
          if (newParent) {
            parentStack.push(newParent);
          }
        } else if (level < currentLevel) {
          // Moving back up the hierarchy - pop parents from stack
          while (currentLevel > level && parentStack.length > 1) {
            parentStack.pop();
            currentLevel--;
          }
        }
        
        // Append to the current parent in the stack
        parentStack[parentStack.length - 1].appendChild(node);
        
        // If this node is a ul, it will be the parent for the next nodes at a deeper level
        if (node.nodeName === "UL") {
          parentStack.push(node);
          currentLevel = level + 1;
        } else {
          currentLevel = level;
        }
      }
      
      Streamlit.setFrameHeight(height);
    }

    window.addEventListener("message", (event) => {
      const data = event.data.args;
      if (data) renderComponent(data);
    });

    Streamlit.setComponentReady(); // Zeigt an, dass die Komponente bereit ist
  })();
</script>
</body>
</html>
